# Queries

Queries are the core data request interface for any Meetup Web Platform app.
They are primarily generated by application Routes to indicate what data each
one needs from the API when it is active. However, they can be used for any
request to the API, and are therefore part of POST and DELETE requests as well.

At a high level, you can think of a Query as a 'tagged' API request, including
all request parameters, the endpoint URI, and any metadata properties like
feature flag requests.

## Spec

A Query is just a plain object with the following shape:

```js
{
  ref: string,
  type: string,
	endpoint: string,
  params: object,
	flags?: string[],
  meta?: {
    method: string
  },
}
```

### `ref`

A unique string reference to the query. The `ref` is used to uniquely identify
the query _and_ uniquely assign the resulting API data to Redux state at
`state.app[ref]`.

### `type`

A one-word description of the 'data type' expected to be returned by the API
for this query. This information is used on the server to further process the
data for certain data types like `'group'` objects, which will receive special
duotone photo URLs in addition to the standard photo URLs provided by the API.

The `type` should be the same regardless of whether the returned data is an
array or a singleton.

**Examples**

- `group`
- `member`
- `event`
- `comment`
- feature-specific objects like `home`, `conversations`

### `endpoint`

The Meetup API endpoint as a URL pathname, e.g. `/members/123456`. Note that
this URL should not include any parameter placeholders like `/:urlname` - the
values should be filled in as needed.

### `params`

The parameters that should be passed to the API either in the querystring (for
GET requests) or the request body (for POST requests).

### `flags`

An array of feature flag (Runtime Flag) names that should be returned
alongside the main request.

### `meta`

#### `method`

You can force the query to be sent with a particular HTTP method by specifying
it here as a string: `get`, `post`, `delete`, or `patch`. Note that
you should never try to make a request that contains multiple queries with
different `method`s.

**Example**

```js
import { apiRequest } from 'meetup-web-platform/lib/actions/syncActionCreators';

// POST request
const postQuery = {
  endpoint: 'ny-tech/members',
  ref: 'newMember',
  params: { name, bio },
  meta: {
    method: 'post',
  },
};
// dispatch it - this might be from a 'bound' action creator rather than from `store.dispatch` directly
store.dispatch(apiRequest([postQuery]));  // note that `apiRequest` takes an _array_ arg

// DELETE request
const deleteQuery = {
  endpoint: 'ny-tech/members/123456',
  ref: 'deletedMember',
  params: { id },
  meta: {
    method: 'delete',
  },
};
store.dispatch(apiRequest([deleteQuery]));  // note that `apiRequest` takes an _array_ arg
```

## Usage

### Query lifecycle.

**Query object created in React app**

```js
{
  ref,
  type,
  endpoint,
  params: {...},
  flags: [...]
}
```

**API request action dispatched through Redux store**

```js
{
  type: 'API_REQUEST',  // or 'POST_...' or '..._POST'
  payload: [query]
}
```

**GET request generated by `fetchUtils.js:fetchQueries`**

```
/mu_api?queries=[query, ...]
```

**API response array returned as JSON from app server**

The app server API endpoint will respond with an array of API responses
structured as individual objects with a single key corresponding to the query
`ref`.

```js
[
  {
    [ref]: {
      type,
      value: {},
      flags,
      meta  // data returned from API separate from `value`
    }
  },
  // ...
]
```

**Redux state after being processed by `API_SUCCESS` action**

```js
{
  [ref]: {
    type,
    value: {},
    flags,
    meta
  },
  // ...
}
```

### Route query functions

One of the primary uses for queries is to load route-specific data from the
API. The application will automatically generate these queries by calling
particular 'query creator' functions that are assigned to application routes,
producing a fully-qualified 'query' object from the routing state input.

Route query creator functions have two requirements:

1. They are assigned as _props_ of React Router `Route`s .The `query` prop can
be either a single query creator function or an array of functions
2. They are pure functions that take the Router's `location` and `params`
extracted from the URL), and deliver a query object for the associated route.

#### Example

```js
export const GROUP_REF = 'group';
function groupQuery({ location, params }) {
	const { urlname } = params;

	return {
		ref: GROUP_REF,
		type: 'group',
		endpoint: `/${urlname}`,
		params: {
			fields: ['event_sample']
		},
	};
}

// applied to a route:

const groupRoute = {
	path: '/:urlname',
	query: groupQuery,
	component: GroupContainer,
};
```

### Accessing data returned by a query

The API endpoint will respond with an array of data, as shown in the
[query lifecycle](#query-lifecycle) section. For navigation and most POST
requests, this response will be passed to an `API_SUCCESS` action, which will
be 'reduced'/injected into the Redux app state at `state.app`, where it can be
accessed with `state.app[ref].value`.

If the response does _not_ trigger an `API_SUCCESS` action, you will have to
write a custom reducer to parse the response data and apply the results to a
different part of `state`. Otherwise, they will be ignored.

## Recipes

### GET (lazy loading)

On page load, the application will automatically collect any query objects
generated by the query functions you assign to your routes. However, if you need
to make another GET request, you can manually dispatch an API request using the
`apiRequest` action creator from
[`syncActionCreators`](../src/actions/syncActionCreators.js).

```js
// Example.jsx
import { apiRequest } from 'meetup-web-platform/lib/actions/syncActionCreators';

function mapDispatchToProps(dispatch) {
  return bindActionCreators({ apiRequest }, dispatch);
}

class Example extends React.Component {
  componentDidMount() {
    const lazyQuery = {
      endpoint: `${this.props.match.params.urlname}/more/stuff`,
      ref: 'moreStuff',
      params: { foo: 'bar' },
    };
    this.props.apiRequest([lazyQuery]);  // pass an array of queries - could be more than one
  }
}
```

### POST

POST requests also use the `apiRequest` action creator used for GET requests -
the query object just needs to have a `meta.method` property with a value of
`'post'`.

```js
// Example.jsx
import { apiRequest } from 'meetup-web-platform/lib/actions/syncActionCreators';

const NEW_STUFF_REF = 'newStuff';

function mapStateToProps(state) {
  // when the POST returns, the response will be accessible in Redux state,
  // populated by an `API_SUCCESS` or `API_ERROR` action
  return {
    NEW_STUFF_REF: state.app[NEW_STUFF_REF],  
  };
}

function mapDispatchToProps(dispatch) {
  return bindActionCreators({ apiRequest }, dispatch);
}

class Example extends React.Component {
  componentWillReceiveProps(nextProps) {
    if (nextProps[NEW_STUFF_REF]) {
      // the POST returned _something_ - maybe an error
      // you probably want to call `this.setState` or something here
    }
  }
  onSubmit(e) {
    e.preventDefault();  // prevent full-page submit
    const postQuery = {
      endpoint: `${this.props.match.params.urlname}/new/stuff`,
      ref: NEW_STUFF_REF,
      params: this.state.formValues,  // this would be set by controlled inputs in the form
      meta: {
        method: 'post',
      }
    };
    this.props.apiRequest([postQuery]);
  }
  render() {
    return (
      <form onSubmit={this.onSubmit}>
        ...
      </form>
    );
  }
}
```

#### Uploading files

API POST/PATCH endpoints that support file uploads have one additional
constraint because the file data cannot be easily JSON-serialized like `params`
in other query objects.

The standard way of encoding form data that includes file uploads is to assemble
the entire form contents into a [`FormData`
instance](https://developer.mozilla.org/en/docs/Web/API/FormData), which
allows the file contents to be passed around the application as a `Blob` that
can be encoded for transmission.

To form a Query with form data, simply pass a `FormData` instance as the
`params` property

```js
// Example.jsx
import { apiRequest } from 'meetup-web-platform/lib/actions/syncActionCreators';

const NEW_FILE_STUFF = 'newFileStuff';

function mapStateToProps(state) {
  // when the POST returns, the response will be accessible in Redux state,
  // populated by an `API_SUCCESS` or `API_ERROR` action
  return {
    NEW_FILE_STUFF: state.app[NEW_FILE_STUFF],  
  };
}

function mapDispatchToProps(dispatch) {
  return bindActionCreators({ apiRequest }, dispatch);
}

class Example extends React.Component {
  componentWillReceiveProps(nextProps) {
    if (nextProps[NEW_FILE_STUFF]) {
      // the POST returned _something_ - maybe an error
      // you probably want to call `this.setState` or something here
    }
  }
  onSubmit(e) {
    e.preventDefault();  // prevent full-page submit
    const postQuery = {
      endpoint: `${this.props.match.params.urlname}/new/stuff`,
      ref: NEW_FILE_STUFF,
      params: new FormData(this.form),  // one stop form encoding - forces 'multipart/form-data' content type
      meta: {
        method: 'post',
      }
    };
    this.props.apiRequest([postQuery]);
  }
  render() {
    return (
      <form
        onSubmit={this.onSubmit}
        ref={el => this.form = el}
      >
        ...
      </form>
    );
  }
}
```

### PATCH

In practice, a PATCH request is just a POST by another name - assign
`meta.method: 'patch'`

### DELETE

In practice, a DELETE request is just a GET by another name - assign
`meta.method: 'delete'`. The response will generally be a '204 - No Content',
so you'll have to read the 'updated' value in Redux state a little more
carefully.

